from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path
from typing import Any

from . import __version__
from .ai.formatter import build_ai_json_payload, render_ai_markdown, write_ai_outputs
from .ai.ollama_provider import OllamaProvider
from .ai.prompts import build_ai_prompt
from .ai.provider import AIProviderError, AIProviderRequest
from .ai.redaction import sanitize_text
from .scan.metrics import collect_metrics
from .scan.reporter import write_reports
from .scan.rules import severity_gte
from .scan.rules_engine import run_security_scan

FAIL_ON_CHOICES = ["NONE", "LOW", "MEDIUM", "HIGH", "CRITICAL"]


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="guardian",
        description="Local-first repository scanner for quality and security risks.",
    )
    parser.add_argument("--version", action="version", version=f"%(prog)s {__version__}")

    subparsers = parser.add_subparsers(dest="command", required=True)

    scan_parser = subparsers.add_parser("scan", help="Scan a repository path")
    scan_parser.add_argument("--version", action="version", version=f"%(prog)s {__version__}")
    scan_parser.add_argument("--path", required=True, help="Target repository directory")
    scan_parser.add_argument("--out", required=True, help="Output directory for reports")
    scan_parser.add_argument(
        "--fail-on",
        default="NONE",
        choices=FAIL_ON_CHOICES,
        type=str.upper,
        help="Fail with exit code 2 if any finding severity is >= threshold.",
    )
    scan_parser.add_argument(
        "--with-semgrep",
        action="store_true",
        help="Enable optional local semgrep integration if available.",
    )

    ai_parser = subparsers.add_parser("ai", help="Generate AI explanation from an existing scan.json")
    ai_parser.add_argument("--scan", required=True, help="Path to scan.json generated by guardian scan")
    ai_parser.add_argument("--out", required=True, help="Path to output markdown report (ai.md)")
    ai_parser.add_argument("--provider", default="ollama", help="LLM provider (default: ollama)")
    ai_parser.add_argument("--model", default="llama3.1:8b", help="Local model name")
    ai_parser.add_argument("--max-findings", type=int, default=25, help="Max findings included in AI prompt")

    return parser


def evaluate_exit_code(findings_severities: list[str], fail_on: str) -> int:
    threshold = (fail_on or "NONE").upper()
    if threshold == "NONE":
        return 0
    for severity in findings_severities:
        if severity_gte(severity, threshold):
            return 2
    return 0


def run_scan(path: Path, out: Path, fail_on: str = "NONE", with_semgrep: bool = False) -> int:
    project_path = path.resolve()
    out_dir = out.resolve()

    metrics = collect_metrics(project_path)
    result = run_security_scan(project_path, metrics=metrics, with_semgrep=with_semgrep)

    exit_code = evaluate_exit_code([finding.severity for finding in result.findings], fail_on)
    write_reports(
        path=project_path,
        out_dir=out_dir,
        metrics=metrics,
        scan_result=result,
        fail_on=fail_on,
        expected_exit_code=exit_code,
    )
    return exit_code


def _validate_scan_payload(payload: dict[str, Any]) -> None:
    required_keys = [
        "schema_version",
        "project_summary",
        "security_summary",
        "ci_status",
        "warnings",
        "security_findings",
    ]
    missing = [key for key in required_keys if key not in payload]
    if missing:
        raise ValueError(f"scan.json no contiene las claves requeridas: {', '.join(missing)}")

    if str(payload.get("schema_version")) != "1.0":
        raise ValueError("scan.json incompatible: schema_version debe ser 1.0")


def _load_scan_json(scan_path: Path) -> dict[str, Any]:
    if not scan_path.exists() or not scan_path.is_file():
        raise FileNotFoundError(f"No existe el archivo scan.json: {scan_path}")

    try:
        payload = json.loads(scan_path.read_text(encoding="utf-8"))
    except json.JSONDecodeError as exc:
        raise ValueError("scan.json no es un JSON valido") from exc

    if not isinstance(payload, dict):
        raise ValueError("scan.json debe ser un objeto JSON")

    _validate_scan_payload(payload)
    return payload


def _select_provider(provider_name: str):
    name = (provider_name or "ollama").strip().lower()
    if name != "ollama":
        raise AIProviderError(f"Provider no soportado: {provider_name}. Solo se permite 'ollama' en modo local-first.")
    return OllamaProvider()


def run_ai(
    scan: Path,
    out: Path,
    provider: str = "ollama",
    model: str = "llama3.1:8b",
    max_findings: int = 25,
) -> int:
    if max_findings <= 0:
        raise ValueError("--max-findings debe ser mayor a 0")

    scan_payload = _load_scan_json(scan.resolve())
    prompt = build_ai_prompt(scan_payload, max_findings=max_findings)

    ai_provider = _select_provider(provider)
    response = ai_provider.generate(AIProviderRequest(model=model, prompt=prompt))

    sanitized = sanitize_text(response.text)
    markdown = render_ai_markdown(model=model, provider=provider, analysis_text=sanitized)
    ai_json = build_ai_json_payload(provider=provider, model=model, analysis_text=sanitized)
    write_ai_outputs(out.resolve(), markdown, ai_json)

    return 0


def main(argv: list[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)

    try:
        if args.command == "scan":
            return run_scan(
                Path(args.path),
                Path(args.out),
                fail_on=args.fail_on,
                with_semgrep=args.with_semgrep,
            )

        if args.command == "ai":
            return run_ai(
                scan=Path(args.scan),
                out=Path(args.out),
                provider=args.provider,
                model=args.model,
                max_findings=args.max_findings,
            )
    except AIProviderError as exc:
        print(str(exc), file=sys.stderr)
        return 3
    except Exception as exc:
        print(str(exc), file=sys.stderr)
        return 1

    parser.error("Unknown command")
    return 2
